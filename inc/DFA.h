/** @file DFA.h
 *  @brief Header for DFA structure
 *  @author Brian Wei
 *
 *  We implement the structure for a DFA with the transition matrix stored as an
 *  array which maps origin state and symbol (as indexes) to the destination state.
 *  This allowed efficient access into the array, which is a highly used operation
 *  within the algorithms that are implemented here.
 *  The DFA_find_pattern function is a brute force algorithm that iterates over
 *  all permutations of states in the DFA to see if there are any suitable in being
 *  a match to the pattern state machine.
 */
#ifndef __VERIF_DFA_H__
#define __VERIF_DFA_H__

#include <string>
#include <vector>
#include <set>

#define DFA_NO_ERROR            (0)
#define DFA_DUMMY_SYMBOL        (-1)
#define DFA_INVALID_ARG         (-2)
#define DFA_MEMORY_ERROR        (-3)
#define DFA_PATTERN_NOT_FOUND   (-4)
#define DFA_NOT_YET_IMPL        (-5)
#define DFA_INVALID_SYMBOL      (-6)


/* Output for when a pattern is identified within a DFA */
class pattern_output {
public:
    std::vector<int> states;    /* States in the DFA */
    std::vector<std::string> symbols;  /* Symbols of the DFA */
};


/* Structure for a DFA; transition matrix is structured as:
*                  symbol
* Starting state   42   99
*             0    0    -1
*             1    1    0
*  where the destination is in the cells of the array, -1 indicates that
*  the transition does noe exist.  Symbols 42 and 99 are specified in the
*  alphabet symbols array which must be in this case {42, 99}
*  */
class dfa {
private:


    void DFA_constructor_helper(int num_states, int alphabet_size, int initial_state,
            std::vector<bool>& finals, const std::vector<std::string>& symbols,
            const int *transition_matrix);
public:
    int num_states;         /* Number of states */
    int initial_state;      /* Initial state    */
    std::set<int> final_states; /* Accepting states */
    std::vector<std::string> alphabet_symbols;  /* Symbols in the alphabet */
    std::vector<std::vector<int>> transition_matrix; /* Transition matrix of
                * num_states * alphabet_size where tm[i][j] is the destination
                * from state i on transition alphabet_symbols[j] */

    /** @brief Constructs a new DFA
     *
     * @param num_states Number of states in the DFA
     * @param alphabet_size Size of the alphabet
     * @param finals List of final states
     * @param transition_matrix Transition matrix
     */
    dfa(int num_states, int alphabet_size, int initial_state,
        std::vector<bool>& finals, const std::vector<std::string>& symbols,
        const int *transition_matrix);

    /** @brief Takes the parallel composition of two dfa's
     *
     * @param dfa_1 First input DFA
     * @param dfa_2 Second input DFA
     */
    dfa(dfa& dfa_1, dfa& dfa_2);

    /** @brief Constructs a clone of a DFA
     *
     * @param source DFA to clone
     */
    dfa(dfa& source);

    /** @brief Returns the index of a given symbol based on the DFA's alphabet
     *
     * @param symbol Symbol to look for
     * @return Index in the alphabet_symbols array of the symbol or a negative error code if not found
     */
    int get_symbol_index(const std::string& symbol);

    /** @brief Runs a trace through a DFA
     *
     * @param trace Input trace, integer array of symbols
     * @return 1 if accept, 0 if reject, negative error code if other failure
     */
    int DFA_run_trace(const std::vector<std::string>& trace);

    /** @brief Finds a pattern DFA withing a given DFA
     *
     * A brute force approach which considers all permutations of states in the DFA and checks
     * that there is some set of symbols for which the transitions will match in the two state
     * machines.
     *
     * @note Returned pointer is generated by a malloc call and thus should be freed after use
     *
     * @param pattern DFA representing the pattern we want
     * @return an array indicating the states and symbols which match the pattern,
     *      or NULL is it cannot be found
     */
    pattern_output *DFA_find_pattern(dfa& pattern, int skip_counter);

    /** @brief Finds a pattern in a DFA and modifies it to a target pattern
     *
     * @note Does not currently support when original_pattern and target_pattern have a different
     *          number of states
     * @todo Document this
     *
     * @param original_pattern
     * @param target_pattern
     * @return 0 on success, negative error code on failure
     */
    int DFA_modify(dfa& original_pattern, dfa& target_pattern, int skips);

    /** @brief Prints information representing the construction of the DFA to specified file
     *
     * @param f File pointer for output
     */
    void DFA_print(FILE *f) const;

    /** @brief Applies a symbol to a DFA from a given state
     *
     * @param current_state state on which to execute
     * @param symbol Symbol to use in execution
     * @return destination state or negative error code on error
     */
    int DFA_apply_symbol(int current_state, const std::string& symbol);
};

#endif /* __VERIF_DFA_H__ */

